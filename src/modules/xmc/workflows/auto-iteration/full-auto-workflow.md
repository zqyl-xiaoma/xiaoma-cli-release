# 全自动迭代开发工作流

> **工作流 ID**: auto-iterate
> **触发命令**: `*auto-iterate`
> **智能体**: Phoenix (全自动化迭代开发编排器)

---

## 智能体命令快速参考

> **重要**: 本工作流通过唤醒专业智能体并执行其特定命令来完成各阶段任务。

### 智能体命令汇总表

| 智能体 | 唤醒命令 | 核心工作流命令 | 用途 |
|--------|---------|---------------|------|
| Mary (Analyst) | `/analyst` | `*product-brief`, `*research` | 需求分析、业务规则匹配 |
| John (PM) | `/pm` | `*create-prd`, `*create-epics-and-stories` | PRD 创建、史诗故事定义 |
| Winston (Architect) | `/architect` | `*create-architecture`, `*validate-architecture` | 架构设计、技术决策 |
| Bob (SM) | `/sm` | `*sprint-planning`, `*create-story` | Sprint 规划、故事准备 |
| Amelia (DEV) | `/dev` | `*develop-story`, `*code-review` | TDD 开发、代码审查 |
| Murat (TEA) | `/tea` | `*trace`, `*test-review`, `*nfr-assess` | 测试追溯、质量验证 |
| Phoenix (Orchestrator) | `/phoenix` | `*auto-iterate`, `*phase-*` | 全自动编排 |

---

## 知识库集成

### 知识库配置

```yaml
knowledge_base:
  # 当前模式: rag (前期) | mcp (后期)
  mode: "rag"

  # RAG 模式配置
  rag:
    file_path: "{project-root}/docs/rag/rag.md"

  # MCP 模式配置 (未来)
  mcp:
    server: "knowledge-base-mcp"
    endpoint: "mcp__kb__query"
```

### 知识库调用机制

在执行过程中，遇到以下场景时会自动查询知识库：

| 阶段 | 调用场景 | 查询类型 |
|-----|---------|---------|
| Phase 1 | 遇到业务术语 | 业务 |
| Phase 1 | 识别功能需求时验证业务规则 | 业务 |
| Phase 1 | 分析业务流程 | 业务 |
| Phase 2 | 创建用户故事时查询角色定义 | 业务 |
| Phase 2 | 定义验收标准时查询参考模板 | 业务+技术 |
| Phase 2 | 定义NFR时查询标准 | 技术 |
| Phase 3 | 技术选型时查询规范 | 技术 |
| Phase 3 | 架构设计时查询模式 | 技术 |
| Phase 3 | API设计时查询规范 | 技术 |
| Phase 4 | 编写代码时查询编码规范 | 技术 |
| Phase 4 | 实现业务逻辑时查询规则 | 业务 |
| Phase 4 | 编写测试时查询测试规范 | 技术 |
| Phase 5 | 验证覆盖率时查询要求 | 技术 |
| Phase 5 | 质量门禁检查时查询标准 | 技术 |

**详细调用点定义**: 参见 `knowledge-base/kb-call-points.md`

---

## 工作流概述

本工作流实现从需求文档到代码实现的全自动化执行，融合7大智能体能力，通过知识库驱动所有决策，实现零人工干预的端到端开发。

### 智能体工作流集成汇总

> **重要**: 本工作流严格遵循项目现有智能体的标准工作流，确保完全兼容。
> **关键变更**: Phase 4 现在包含完整的故事生命周期（包括测试验证），每个故事从创建到验证完成后才处理下一个故事。

| 阶段 | 集成智能体 | 调用的工作流 | 用途 | 故事状态 |
|------|-----------|-------------|------|----------|
| Phase 1 | Mary (Analyst) | 内置分析能力 | 需求分析、业务规则匹配 | - |
| Phase 2 | John (PM) | 内置 PRD 能力 | PRD 创建、史诗故事定义 | - |
| Phase 3 | Winston (Architect) | 内置架构能力 | 架构设计、技术决策 | - |
| Phase 4 Step 4.1 | Bob (SM) | `*sprint-planning` | 生成 sprint-status.yaml | - |
| Phase 4 STEP 1 | Bob (SM) | `*create-story` | 创建故事文件 | backlog→drafted |
| Phase 4 STEP 2 | Bob (SM) | `*validate-create-story` | 校验故事文件 | drafted→ready-for-dev |
| Phase 4 STEP 3 | Amelia (DEV) | `*develop-story` | TDD 开发 | ready-for-dev→in-progress |
| Phase 4 STEP 4 | Amelia (DEV) | `*code-review` | 代码审查 | in-progress→review |
| Phase 4 STEP 5 | Murat (TEA) | `*trace` + `*test-review` | 测试验证 | review→done |
| Phase 5 (可选) | Murat (TEA) | `*nfr-assess` | Sprint 最终报告 | - |

### 故事状态系统 (6状态流转)

```
backlog → drafted → ready-for-dev → in-progress → review → done
   │         │            │              │           │       │
   │         │            │              │           │       └─ 故事完成
   │         │            │              │           └─ 等待代码审查
   │         │            │              └─ 开发进行中
   │         │            └─ 可以开始开发
   │         └─ 故事文件已创建
   └─ 仅存在于 Epic 文件中
```

**状态转换触发点 (完整故事生命周期)**:
- `backlog → drafted`: STEP 1 - SM `*create-story` 创建故事文件
- `drafted → ready-for-dev`: STEP 2 - SM `*validate-create-story` 验证通过
- `ready-for-dev → in-progress`: STEP 3 - DEV `*develop-story` 开始开发
- `in-progress → review`: STEP 4 - DEV `*code-review` 代码审查开始
- `review → done`: STEP 5 - TEA `*trace` + `*test-review` 测试验证通过
- `review → in-progress`: 代码审查或测试验证未通过 (返回修复)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        全自动迭代开发流程                                  │
├─────────────────────────────────────────────────────────────────────────┤
│  输入                                                                    │
│  ├─ 📄 迭代需求文档（产品经理提供）                                        │
│  ├─ 📚 业务知识库（业务规则、领域知识）                                     │
│  └─ 🔧 技术知识库（技术规范、代码规范、架构模式）                            │
├─────────────────────────────────────────────────────────────────────────┤
│  Phase 1: 需求分析 [Analyst 能力]                                        │
│  ├─ 解析需求文档                                                         │
│  ├─ 匹配业务知识库规则                                                    │
│  ├─ 识别隐含需求和约束                                                    │
│  └─ 输出: 结构化需求分析报告                                              │
├─────────────────────────────────────────────────────────────────────────┤
│  Phase 2: 需求规划 [PM + PO 能力]                                        │
│  ├─ 创建 PRD 文档                                                        │
│  ├─ 定义功能需求 (FRs)                                                   │
│  ├─ 定义非功能需求 (NFRs)                                                │
│  ├─ 创建史诗和用户故事                                                    │
│  └─ 输出: PRD + Epic + Stories                                          │
├─────────────────────────────────────────────────────────────────────────┤
│  Phase 3: 架构设计 [Architect 能力]                                      │
│  ├─ 分析现有代码架构                                                      │
│  ├─ 设计技术方案                                                         │
│  ├─ 匹配技术知识库规范                                                    │
│  ├─ 创建数据模型设计                                                      │
│  └─ 输出: 架构设计文档 + ADR                                             │
├─────────────────────────────────────────────────────────────────────────┤
│  Phase 4: 开发实现与测试验证 [SM + DEV + TEA 能力]                        │
│  ├─ Sprint 规划 (SM)                                                    │
│  ├─ 🔄 For Each Story 完整生命周期循环:                                   │
│  │   ├─ STEP 1: 创建用户故事 (SM)                                        │
│  │   ├─ STEP 2: 校验用户故事 (SM)                                        │
│  │   ├─ STEP 3: 开发用户故事 (DEV - TDD)                                 │
│  │   ├─ STEP 4: 代码审查 (DEV)                                           │
│  │   ├─ STEP 5: 测试验证 (TEA - 追溯+质量检查)                            │
│  │   └─ ✅ 故事完成 → 开始下一个故事                                      │
│  └─ 输出: 实现的代码 + 测试 + 每个故事的验证报告                           │
├─────────────────────────────────────────────────────────────────────────┤
│  Phase 5: Sprint 收尾与最终报告 [TEA 能力] (可选)                          │
│  ├─ 生成 Sprint 完整追溯矩阵                                              │
│  ├─ 生成整体质量报告                                                      │
│  ├─ NFR 综合验证                                                         │
│  └─ 输出: 迭代完成报告 + 质量总结                                          │
├─────────────────────────────────────────────────────────────────────────┤
│  输出                                                                    │
│  ├─ ✅ 完整的代码实现                                                     │
│  ├─ ✅ 完整的测试覆盖                                                     │
│  ├─ ✅ 完整的文档产出                                                     │
│  └─ ✅ 执行报告和追溯记录                                                  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 执行指令

当用户输入 `*auto-iterate` 时，按以下流程自动执行：

### Step 0: 初始化

```markdown
## 初始化检查清单

1. **检查必要输入**
   - [ ] 迭代需求文档路径或内容
   - [ ] 目标项目路径

2. **加载知识库 (RAG 模式)**
   - 读取 `{project-root}/docs/rag/rag.md` 文件
   - 解析知识库结构（业务知识 + 技术知识）
   - 构建关键词索引

3. **创建执行状态文件**
   - 创建 `auto-iteration-status.yaml`
   - 记录开始时间和初始状态
   - 记录知识库加载状态
```

**执行动作**：

```
## 启动全自动迭代开发

### 第一步：加载知识库

正在读取知识库文件: {project-root}/docs/rag/rag.md

**知识库加载结果**:
- 业务术语: X 条
- 业务规则: X 条
- 业务流程: X 条
- 技术规范: X 条
- 编码规范: X 条
- 架构模式: X 条

✅ 知识库加载完成

### 第二步：请提供迭代需求

请粘贴产品经理提供的迭代需求文档内容：

### 第三步：确认项目路径

目标代码库路径: {project-root}
确认后将开始全自动执行。
```

**知识库查询示例**：

在执行过程中，当遇到需要查询知识库的场景时，将按以下格式执行：

```yaml
# 知识库查询
call_point: "KBC-1.2"
question: "请查询与用户偏好设置相关的业务规则"
source: "{project-root}/docs/rag/rag.md"

# 执行步骤
1. 提取关键词: ["用户", "偏好", "设置", "业务规则"]
2. 在 rag.md 中搜索匹配章节
3. 返回匹配内容

# 查询结果
found: true
content: |
  ### 规则: BR-003 偏好设置规则
  - 每个用户可设置最多100个偏好项
  - 偏好键名长度不超过100字符
  - ...
source_section: "业务规则 > BR-003"
confidence: "high"

# 决策
基于知识库 BR-003 规则，实现中必须：
1. 限制偏好数量为100
2. 验证键名长度
3. ...
```

---

### Step 1: 需求分析阶段 (Phase 1)

**角色激活**: Analyst (需求分析师)

---

#### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1: 需求分析                                               │
│  智能体: Mary (Analyst)                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Step 1.1: 唤醒 Analyst 智能体                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: /analyst                                          ││
│  │ 说明: 唤醒业务分析师 Mary，准备进行需求分析工作                ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 1.2: 执行产品简报/调研工作流                                │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *product-brief                                    ││
│  │ 说明: 基于迭代需求文档，创建结构化的产品简报                   ││
│  │ 输入: 迭代需求文档内容                                        ││
│  │ 输出: product-brief.md                                      ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 1.3: (可选) 执行深度调研                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *research                                         ││
│  │ 说明: 针对复杂需求进行市场/竞品/技术调研                      ││
│  │ 触发条件: 需求涉及新业务领域或技术栈                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 1.4: 生成需求分析报告                                      │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 基于 *product-brief 输出，整理为 requirement-analysis.md    ││
│  │ 确保包含: 功能点清单、业务规则、隐含需求、约束和风险          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**完整执行序列**:
```bash
# 1. 唤醒 Analyst 智能体
/analyst

# 2. 执行产品简报工作流
*product-brief

# 3. (可选) 执行深度调研
*research
```

---

**自动执行内容**:

```yaml
phase: 1
name: 需求分析
role: Analyst (Mary)
agent_activation:
  command: "/analyst"
  workflows:
    - trigger: "*product-brief"
      purpose: "创建产品简报，提取核心需求"
    - trigger: "*research"
      purpose: "深度调研（可选）"
      condition: "需求涉及新业务领域时执行"
inputs:
  - 迭代需求文档
  - 业务知识库
outputs:
  - requirement-analysis.md (基于 product-brief 整理)

tasks:
  - name: 解析需求文档
    agent_command: "/analyst → *product-brief"
    action: |
      1. 读取需求文档全文
      2. 提取功能点列表
      3. 提取业务规则
      4. 提取约束条件

  - name: 匹配业务知识库
    action: |
      1. 在知识库中检索相关业务规则
      2. 验证需求与现有业务规则的一致性
      3. 识别需要新增的业务规则
      4. 标记潜在的业务冲突

  - name: 识别隐含需求
    action: |
      1. 基于业务知识推断隐含需求
      2. 基于技术约束推断非功能需求
      3. 基于用户场景推断边界条件

  - name: 生成分析报告
    output: requirement-analysis.md
    template: |
      # 需求分析报告

      ## 1. 需求概述
      [从需求文档提取的核心需求描述]

      ## 2. 功能点清单
      | ID | 功能点 | 优先级 | 知识库匹配 |
      |----|-------|-------|-----------|

      ## 3. 业务规则匹配
      ### 已匹配的业务规则
      [从知识库匹配到的规则]

      ### 新增业务规则
      [需要新增的规则]

      ## 4. 隐含需求
      [推断出的隐含需求]

      ## 5. 约束和风险
      [识别的约束条件和潜在风险]

      ## 6. 下一阶段输入
      [为 Phase 2 准备的结构化输入]
```

**质量门禁**:
- [ ] 所有功能点都已识别
- [ ] 业务规则匹配率 > 80%
- [ ] 无未解决的业务冲突

**阻塞处理**:
- 如果业务规则匹配率 < 80%，自动在知识库中扩大搜索范围
- 如果存在业务冲突，记录冲突并标记为"需确认"，继续执行

---

### Step 2: 需求规划阶段 (Phase 2)

**角色激活**: PM (产品经理) + PO (产品负责人)

---

#### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 2: 需求规划                                               │
│  智能体: John (PM)                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Step 2.1: 唤醒 PM 智能体                                        │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: /pm                                               ││
│  │ 说明: 唤醒产品经理 John，准备进行需求规划工作                  ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 2.2: 创建 PRD 文档                                         │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *create-prd                                       ││
│  │ 说明: 基于需求分析报告，创建完整的产品需求文档                 ││
│  │ 输入: requirement-analysis.md / product-brief.md            ││
│  │ 输出: prd.md                                                ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 2.3: (推荐) 验证 PRD                                       │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *validate-prd                                     ││
│  │ 说明: 使用全新上下文和不同 LLM 验证 PRD 质量                  ││
│  │ 建议: 使用不同的 LLM 以获得更客观的评估                       ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 2.4: 创建史诗和故事定义                                    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *create-epics-and-stories                         ││
│  │ 说明: 从 PRD 创建史诗和用户故事（在架构完成后执行）           ││
│  │ 输入: prd.md + architecture.md                              ││
│  │ 输出: epics/epic-XXX.md                                     ││
│  │ ⚠️ 注意: 故事定义写在 Epic 文件中，独立故事文件在 Phase 4    ││
│  │         由 SM 的 *create-story 创建                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**完整执行序列**:
```bash
# 1. 唤醒 PM 智能体
/pm

# 2. 创建 PRD 文档
*create-prd

# 3. (推荐) 验证 PRD
*validate-prd

# 4. 创建史诗和故事定义 (需在架构设计后执行)
*create-epics-and-stories
```

---

**自动执行内容**:

```yaml
phase: 2
name: 需求规划
role: PM (John) + PO
agent_activation:
  command: "/pm"
  workflows:
    - trigger: "*create-prd"
      purpose: "创建产品需求文档"
    - trigger: "*validate-prd"
      purpose: "验证 PRD 质量（推荐）"
    - trigger: "*create-epics-and-stories"
      purpose: "创建史诗和故事定义"
      prerequisite: "需在架构设计完成后执行"
inputs:
  - requirement-analysis.md
  - 业务知识库
outputs:
  - prd.md
  - epics/epic-XXX.md  # 包含故事定义的 Epic 文件
  # 注意: 独立故事文件将在 Phase 4 由 *create-story 创建

tasks:
  - name: 创建 PRD
    agent_command: "/pm → *create-prd"
    action: |
      1. 基于需求分析报告创建 PRD
      2. 定义产品目标和成功指标
      3. 详细描述每个功能需求 (FR)
      4. 定义非功能需求 (NFR)
    output: prd.md

  - name: 创建史诗文件（包含故事定义）
    agent_command: "/pm → *create-epics-and-stories"
    action: |
      1. 将功能需求按模块分组为史诗
      2. 定义每个史诗的业务价值
      3. 确定史诗间的依赖关系
      4. ⚠️ 重要: 故事定义写在 Epic 文件中，不单独创建故事文件
      5. 故事文件将在 Phase 4 由 SM *create-story 工作流创建
    output: epics/epic-XXX.md
    note: |
      ⚠️ Phase 2 不创建独立的故事文件！
      故事的详细定义（用户故事、接受标准、任务分解）应写在 Epic 文件中。
      Phase 4 的 *create-story 工作流会：
      1. 从 Epic 文件提取故事定义
      2. 创建符合 DEV 智能体格式的故事文件
      3. 自动设置正确的 Status: drafted

  - name: PO 验收标准审核
    action: |
      1. 验证每个故事的业务价值
      2. 确认接受标准完整性
      3. 确认优先级排序
```

**PRD 模板**:

```markdown
# 产品需求文档 (PRD)

## 1. 产品概述
### 1.1 背景
### 1.2 目标
### 1.3 成功指标

## 2. 功能需求 (FRs)
### FR-001: [功能名称]
- **描述**:
- **用户故事**: As a [角色], I want [功能], So that [价值]
- **接受标准**:
  - Given [前置条件]
  - When [操作]
  - Then [预期结果]
- **优先级**: P0/P1/P2
- **知识库依据**: [引用的业务规则]

## 3. 非功能需求 (NFRs)
### NFR-001: 性能要求
### NFR-002: 安全要求
### NFR-003: 可用性要求

## 4. 依赖和约束
## 5. 风险和缓解措施
```

**质量门禁**:
- [ ] PRD 覆盖所有已识别的功能点
- [ ] 每个故事都有明确的接受标准
- [ ] 故事点估算完成
- [ ] 优先级排序完成

---

### Step 3: 架构设计阶段 (Phase 3)

**角色激活**: Architect (架构师)

---

#### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 3: 架构设计                                               │
│  智能体: Winston (Architect)                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Step 3.1: 唤醒 Architect 智能体                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: /architect                                        ││
│  │ 说明: 唤醒架构师 Winston，准备进行架构设计工作                 ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 3.2: 创建架构文档                                          │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *create-architecture                              ││
│  │ 说明: 基于 PRD 创建完整的架构设计文档                         ││
│  │ 输入: prd.md + 现有代码库                                    ││
│  │ 输出: architecture.md + adr/                                ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 3.3: (推荐) 验证架构                                       │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *validate-architecture                            ││
│  │ 说明: 使用全新上下文和不同 LLM 验证架构设计                   ││
│  │ 建议: 使用不同的 LLM 以获得更客观的评估                       ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 3.4: (可选) 实现准备验证                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *implementation-readiness                         ││
│  │ 说明: 验证 PRD、UX、架构、史诗和故事是否对齐                  ││
│  │ 建议: 在进入 Phase 4 开发前执行此验证                        ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 3.5: (可选) 创建架构图                                     │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *create-excalidraw-diagram                        ││
│  │ 说明: 创建系统架构图或技术图表                                ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 3.6: (可选) 创建数据流图                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *create-excalidraw-dataflow                       ││
│  │ 说明: 创建数据流图                                           ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**完整执行序列**:
```bash
# 1. 唤醒 Architect 智能体
/architect

# 2. 创建架构文档
*create-architecture

# 3. (推荐) 验证架构
*validate-architecture

# 4. (可选) 实现准备验证
*implementation-readiness

# 5. (可选) 创建架构图
*create-excalidraw-diagram
```

---

**自动执行内容**:

```yaml
phase: 3
name: 架构设计
role: Architect (Winston)
agent_activation:
  command: "/architect"
  workflows:
    - trigger: "*create-architecture"
      purpose: "创建架构设计文档"
    - trigger: "*validate-architecture"
      purpose: "验证架构设计（推荐）"
    - trigger: "*implementation-readiness"
      purpose: "实现准备验证（可选）"
    - trigger: "*create-excalidraw-diagram"
      purpose: "创建架构图（可选）"
    - trigger: "*create-excalidraw-dataflow"
      purpose: "创建数据流图（可选）"
inputs:
  - prd.md
  - epics/
  - 技术知识库
  - 现有代码库
outputs:
  - architecture.md
  - adr/

tasks:
  - name: 分析现有架构
    agent_command: "/architect → *create-architecture (Step 1)"
    action: |
      1. 扫描目标代码库结构
      2. 识别现有技术栈
      3. 识别现有架构模式
      4. 识别可复用组件

  - name: 设计技术方案
    agent_command: "/architect → *create-architecture (Step 2)"
    action: |
      1. 基于 PRD 设计技术实现方案
      2. 匹配技术知识库中的最佳实践
      3. 设计新增组件和模块
      4. 设计 API 接口

  - name: 数据模型设计
    agent_command: "/architect → *create-architecture (Step 3)"
    action: |
      1. 设计新增/变更的数据表
      2. 创建 ER 图
      3. 设计数据迁移策略

  - name: 技术决策记录
    agent_command: "/architect → *create-architecture (Step 4)"
    action: |
      1. 记录关键技术选型
      2. 记录选型理由和权衡
      3. 引用技术知识库依据
    output: adr/
```

**架构文档模板**:

```markdown
# 架构设计文档

## 1. 系统架构概览
### 1.1 架构图
[Mermaid 图]

### 1.2 组件说明

## 2. 技术决策
### ADR-001: [决策标题]
- **状态**: 已采纳
- **上下文**: [为什么需要这个决策]
- **决策**: [具体决策内容]
- **理由**: [为什么这样决策]
- **知识库依据**: [引用的技术规范]

## 3. 数据模型
### 3.1 ER 图
### 3.2 表结构设计

## 4. API 设计
### 4.1 新增接口
### 4.2 变更接口

## 5. 文件变更清单
| 文件路径 | 变更类型 | 说明 |
|---------|---------|------|
```

**质量门禁**:
- [ ] 架构设计覆盖所有功能需求
- [ ] 技术决策都有知识库依据
- [ ] 数据模型设计完整
- [ ] API 设计符合现有规范

---

### Step 4: 开发实现阶段 (Phase 4)

**角色激活**: SM (Scrum Master - Bob) + DEV (Developer - Amelia)

> **重要**: 本阶段严格遵循项目智能体的标准工作流，确保与 SM 和 DEV 智能体的完全兼容。

---

#### ⛔ 强制性执行约束 (MANDATORY CONSTRAINTS)

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║                    🚨 绝对禁止 - ABSOLUTELY FORBIDDEN 🚨                       ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  1. ❌ 禁止跳过故事文件创建                                                    ║
║     - 绝对禁止直接基于 Epic 进行开发                                           ║
║     - 每个故事必须先创建独立的故事文件到 /sprint-artifacts/stories/ 目录        ║
║     - 没有故事文件 = 不允许开发                                                ║
║                                                                               ║
║  2. ❌ 禁止跳过故事验证                                                        ║
║     - 故事文件创建后必须执行 *validate-create-story 验证                       ║
║     - 验证未通过 = 不允许进入开发阶段                                          ║
║                                                                               ║
║  3. ❌ 禁止跳过单元测试                                                        ║
║     - 开发完成后必须执行单元测试                                               ║
║     - 测试未通过 = 不允许进入代码审查阶段                                       ║
║                                                                               ║
║  4. ❌ 禁止跳过代码审查                                                        ║
║     - 所有代码必须通过 *code-review 审查                                       ║
║     - 审查未通过 = 必须返回修复                                                ║
║                                                                               ║
║  5. ❌ 禁止批量处理多个故事                                                    ║
║     - 必须一个故事一个故事地完成                                               ║
║     - 当前故事未完成 = 不允许开始下一个故事                                     ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

#### ✅ 用户故事完整生命周期 5 步强制流程 (MANDATORY 5-STEP LIFECYCLE)

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║            🔄 用户故事完整生命周期 (每个故事必须完成全部 5 步)                    ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  ⚠️ 关键原则: 每个故事必须完成从创建到测试验证的完整生命周期后,                  ║
║               才能开始下一个故事！禁止批量开发后统一测试！                        ║
║                                                                               ║
║  对于 sprint-status.yaml 中的每一个故事，必须严格按以下顺序执行:                 ║
║                                                                               ║
║  ┌─────────────────────────────────────────────────────────────────────────┐  ║
║  │ STEP 1: 创建用户故事 (CREATE) [SM - Bob]                                │  ║
║  │ ┌─────────────────────────────────────────────────────────────────────┐ │  ║
║  │ │ 命令: /sm → *create-story                                          │ │  ║
║  │ │ 输出: /sprint-artifacts/stories/{story-key}.md                     │ │  ║
║  │ │ 状态: backlog → drafted                                            │ │  ║
║  │ │ 🚨 门禁: 必须确认文件已创建在 stories/ 目录下                        │ │  ║
║  │ └─────────────────────────────────────────────────────────────────────┘ │  ║
║  └─────────────────────────────────────────────────────────────────────────┘  ║
║                                    ↓                                          ║
║  ┌─────────────────────────────────────────────────────────────────────────┐  ║
║  │ STEP 2: 校验用户故事 (VALIDATE) [SM - Bob]                              │  ║
║  │ ┌─────────────────────────────────────────────────────────────────────┐ │  ║
║  │ │ 命令: /sm → *validate-create-story                                 │ │  ║
║  │ │ 检查: 接受标准完整性、任务分解合理性、技术说明充分性                  │ │  ║
║  │ │ 状态: drafted → ready-for-dev                                      │ │  ║
║  │ │ 🚨 门禁: 验证必须通过，否则返回 STEP 1 修正                          │ │  ║
║  │ └─────────────────────────────────────────────────────────────────────┘ │  ║
║  └─────────────────────────────────────────────────────────────────────────┘  ║
║                                    ↓                                          ║
║  ┌─────────────────────────────────────────────────────────────────────────┐  ║
║  │ STEP 3: 开发用户故事 (DEVELOP) [DEV - Amelia]                           │  ║
║  │ ┌─────────────────────────────────────────────────────────────────────┐ │  ║
║  │ │ 命令: /dev → *develop-story                                        │ │  ║
║  │ │ 执行: TDD 驱动开发 (红-绿-重构) + 单元测试 100% 通过                 │ │  ║
║  │ │ 状态: ready-for-dev → in-progress                                  │ │  ║
║  │ │ 🚨 前置: 必须有 ready-for-dev 状态的故事文件                         │ │  ║
║  │ │ 🚨 门禁: 所有单元测试必须 100% 通过                                  │ │  ║
║  │ └─────────────────────────────────────────────────────────────────────┘ │  ║
║  └─────────────────────────────────────────────────────────────────────────┘  ║
║                                    ↓                                          ║
║  ┌─────────────────────────────────────────────────────────────────────────┐  ║
║  │ STEP 4: 代码审查 (CODE REVIEW) [DEV - Amelia]                           │  ║
║  │ ┌─────────────────────────────────────────────────────────────────────┐ │  ║
║  │ │ 命令: /dev → *code-review                                          │ │  ║
║  │ │ 审查: 功能正确性 + 代码质量 + 安全性 + 测试覆盖                      │ │  ║
║  │ │ 状态: in-progress → review                                         │ │  ║
║  │ │ 🚨 门禁: APPROVED 继续，CHANGES_REQUESTED 返回 STEP 3 修复          │ │  ║
║  │ └─────────────────────────────────────────────────────────────────────┘ │  ║
║  └─────────────────────────────────────────────────────────────────────────┘  ║
║                                    ↓                                          ║
║  ┌─────────────────────────────────────────────────────────────────────────┐  ║
║  │ STEP 5: 测试验证 (TEST VERIFICATION) [TEA - Murat]                      │  ║
║  │ ┌─────────────────────────────────────────────────────────────────────┐ │  ║
║  │ │ 命令: /tea → *trace + *test-review                                 │ │  ║
║  │ │ 验证: 需求追溯完整性 + 测试质量评审 + 集成测试                       │ │  ║
║  │ │ 状态: review → done (通过) 或 review → in-progress (返回修复)       │ │  ║
║  │ │ 🚨 门禁: 追溯完整 + 测试质量通过才能标记 done                        │ │  ║
║  │ └─────────────────────────────────────────────────────────────────────┘ │  ║
║  └─────────────────────────────────────────────────────────────────────────┘  ║
║                                                                               ║
║  ✅ 故事完成: 状态变为 done，🔄 返回 STEP 1 开始下一个故事                      ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

#### 📋 故事文件存在性验证 (FILE EXISTENCE VALIDATION)

```yaml
# 在开始开发任何故事之前，必须执行以下验证:

validation_before_development:
  check_1_sprint_status_exists:
    file: "{sprint_artifacts}/sprint-status.yaml"
    error_if_missing: "❌ 必须先执行 /sm → *sprint-planning 生成 sprint-status.yaml"

  check_2_story_file_exists:
    file: "{sprint_artifacts}/stories/{story-key}.md"
    error_if_missing: "❌ 必须先执行 /sm → *create-story 创建故事文件"

  check_3_story_status_valid:
    condition: "故事文件中 Status: 必须是 ready-for-dev"
    error_if_invalid: "❌ 故事状态不是 ready-for-dev，必须先通过验证"

# 验证命令示例:
verification_commands:
  - "ls {sprint_artifacts}/sprint-status.yaml  # 确认存在"
  - "ls {sprint_artifacts}/stories/             # 列出所有故事文件"
  - "grep 'Status:' {sprint_artifacts}/stories/{story-key}.md  # 检查状态"
```

---

#### 🤖 智能体执行指令概览

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 4: 开发实现与测试验证                                     │
│  智能体: Bob (SM) + Amelia (DEV) + Murat (TEA)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  阶段流程概览:                                                    │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────────┐
│  │ Step 4.1: Sprint 规划 (SM)                                   │
│  │ ┌────────────────────────────────────────────────────────┐   │
│  │ │ 执行: /sm → *sprint-planning                           │   │
│  │ │ 输出: sprint-status.yaml                               │   │
│  │ │ 🚨 门禁: 必须生成 sprint-status.yaml 才能继续          │   │
│  │ └────────────────────────────────────────────────────────┘   │
│  └──────────────────────────────────────────────────────────────┘
│                              ↓                                   │
│  ┌──────────────────────────────────────────────────────────────┐
│  │ Step 4.2: 🔄 For Each Story 完整生命周期循环                 │
│  │ ⚠️ 每个故事必须完成全部 5 步后才能开始下一个故事！           │
│  │                                                              │
│  │   STEP 1: 创建用户故事 (SM - Bob) 🔴 必须                    │
│  │   ┌────────────────────────────────────────────────────┐     │
│  │   │ 执行: /sm → *create-story                          │     │
│  │   │ 输出: /sprint-artifacts/stories/{story-key}.md     │     │
│  │   │ 状态: backlog → drafted                            │     │
│  │   │ 🚨 门禁: 确认文件已创建                             │     │
│  │   └────────────────────────────────────────────────────┘     │
│  │                         ↓                                    │
│  │   STEP 2: 校验用户故事 (SM - Bob) 🔴 必须                    │
│  │   ┌────────────────────────────────────────────────────┐     │
│  │   │ 执行: /sm → *validate-create-story                 │     │
│  │   │ 检查: AC完整性、任务分解、技术说明                   │     │
│  │   │ 状态: drafted → ready-for-dev                      │     │
│  │   │ 🚨 门禁: 验证通过才能继续                           │     │
│  │   └────────────────────────────────────────────────────┘     │
│  │                         ↓                                    │
│  │   STEP 3: 开发用户故事 (DEV - Amelia) 🔴 必须                │
│  │   ┌────────────────────────────────────────────────────┐     │
│  │   │ 执行: /dev → *develop-story                        │     │
│  │   │ 内容: TDD 开发 + 单元测试 100% 通过                 │     │
│  │   │ 状态: ready-for-dev → in-progress                  │     │
│  │   │ 🚨 门禁: 单元测试 100% 通过                         │     │
│  │   └────────────────────────────────────────────────────┘     │
│  │                         ↓                                    │
│  │   STEP 4: 代码审查 (DEV - Amelia) 🔴 必须                    │
│  │   ┌────────────────────────────────────────────────────┐     │
│  │   │ 执行: /dev → *code-review                          │     │
│  │   │ 审查: 功能 + 代码质量 + 安全 + 测试覆盖             │     │
│  │   │ 状态: in-progress → review                         │     │
│  │   │ 🚨 门禁: APPROVED 继续，否则返回 STEP 3             │     │
│  │   └────────────────────────────────────────────────────┘     │
│  │                         ↓                                    │
│  │   STEP 5: 测试验证 (TEA - Murat) 🔴 必须                     │
│  │   ┌────────────────────────────────────────────────────┐     │
│  │   │ 执行: /tea → *trace + *test-review                 │     │
│  │   │ 验证: 需求追溯 + 测试质量 + 集成测试                │     │
│  │   │ 状态: review → done (通过) 或 返回修复              │     │
│  │   │ 🚨 门禁: 追溯完整 + 质量通过才标记 done             │     │
│  │   └────────────────────────────────────────────────────┘     │
│  │                                                              │
│  │   ✅ 故事完成 → 🔄 返回 STEP 1 开始下一个故事                │
│  └──────────────────────────────────────────────────────────────┘
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**完整执行序列 (5 步强制流程)**:
```bash
# === Step 4.1: Sprint 规划 ===
# 1. 唤醒 SM 智能体
/sm

# 2. 执行 Sprint 规划
*sprint-planning

# 🚨 门禁检查: 确认 sprint-status.yaml 已生成
ls {sprint_artifacts}/sprint-status.yaml

# === Step 4.2: 🔄 故事完整生命周期循环 (对每个故事重复 5 步流程) ===

# ╔═══════════════════════════════════════════════════════════════╗
# ║ 🔄 FOR EACH STORY - 完整生命周期循环开始                        ║
# ╚═══════════════════════════════════════════════════════════════╝

# ============================================================
# STEP 1: 创建用户故事 (SM - Bob) 🔴 必须执行
# ============================================================
/sm
*create-story

# 🚨 门禁检查: 确认故事文件已创建
ls {sprint_artifacts}/stories/{story-key}.md

# ============================================================
# STEP 2: 校验用户故事 (SM - Bob) 🔴 必须执行
# ============================================================
/sm
*validate-create-story

# 🚨 门禁检查: 确认故事状态为 ready-for-dev
grep "Status: ready-for-dev" {sprint_artifacts}/stories/{story-key}.md

# ============================================================
# STEP 3: 开发用户故事 (DEV - Amelia) 🔴 必须执行
# ============================================================
/dev
*develop-story

# 🚨 门禁检查: 单元测试必须 100% 通过 (TDD 开发中已执行)
# 如果测试失败，必须修复后重新运行，不允许跳过

# ============================================================
# STEP 4: 代码审查 (DEV - Amelia) 🔴 必须执行
# ============================================================
/dev
*code-review

# 🚨 门禁检查:
# - APPROVED: 继续到 STEP 5
# - CHANGES_REQUESTED: 返回 STEP 3 修复后重新审查

# ============================================================
# STEP 5: 测试验证 (TEA - Murat) 🔴 必须执行
# ============================================================
/tea
*trace           # 需求追溯验证
*test-review     # 测试质量评审

# 🚨 门禁检查:
# - 追溯完整 + 测试质量通过: 故事状态变为 done
# - 验证失败: 返回 STEP 3 修复后重新验证

# ╔═══════════════════════════════════════════════════════════════╗
# ║ ✅ 故事完成 → 🔄 返回 STEP 1 开始下一个故事                    ║
# ╚═══════════════════════════════════════════════════════════════╝
```

---

**故事状态定义** (与 SM 智能体一致):

```yaml
# 故事状态流转 (6状态系统)
story_status:
  backlog: "故事仅存在于 epic 文件中"
  drafted: "故事文件已创建于 stories 文件夹"
  ready-for-dev: "故事草稿已审核，可以开始开发"
  in-progress: "开发者正在积极实现中"
  review: "实现完成，等待代码审查"
  done: "故事已完成"

# Epic 状态
epic_status:
  backlog: "Epic 尚未开始"
  in-progress: "Epic 正在进行中"
  done: "Epic 中所有故事已完成"
```

**自动执行内容**:

```yaml
phase: 4
name: 开发实现与测试验证
inputs:
  - architecture.md
  - epics/*.md  # 包含故事定义的 Epic 文件
  - 技术知识库
outputs:
  - sprint-status.yaml  # 使用 SM 智能体的标准格式
  - stories/*.md  # 独立故事文件
  - 实现的代码
  - 测试代码
  - code-review-reports/
  - traceability-matrix.md  # 需求追溯矩阵
  - test-review-reports/  # 测试质量报告

# 调用的智能体工作流 (完整故事生命周期)
workflows_invoked:
  - step: "STEP 1"
    agent: SM (Bob)
    workflow: create-story
    purpose: "创建用户故事文件"
    status_change: "backlog → drafted"
  - step: "STEP 2"
    agent: SM (Bob)
    workflow: validate-create-story
    purpose: "校验用户故事"
    status_change: "drafted → ready-for-dev"
  - step: "STEP 3"
    agent: DEV (Amelia)
    workflow: develop-story
    purpose: "TDD 驱动的故事实现"
    status_change: "ready-for-dev → in-progress"
  - step: "STEP 4"
    agent: DEV (Amelia)
    workflow: code-review
    purpose: "代码审查验证"
    status_change: "in-progress → review"
  - step: "STEP 5"
    agent: TEA (Murat)
    workflow: trace + test-review
    purpose: "测试验证 (需求追溯 + 测试质量)"
    status_change: "review → done"
```

---

#### Step 4.1: Sprint 规划 (SM 角色)

**调用工作流**: `{xiaoma_folder}/xmc/workflows/4-implementation/sprint-planning/workflow.yaml`

---

##### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 4.1: Sprint 规划                                          │
│  智能体: Bob (SM)                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  执行步骤:                                                        │
│                                                                  │
│  1. 唤醒 SM 智能体                                               │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: /sm                                           │ │
│     │ 说明: 唤醒 Scrum Master Bob，准备进行 Sprint 规划        │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  2. 执行 Sprint 规划工作流                                       │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *sprint-planning                              │ │
│     │ 说明: 分析 Epic 文件，生成 sprint-status.yaml           │ │
│     │ 输入: epics/*.md                                        │ │
│     │ 输出: sprint-status.yaml                                │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行命令**:
```bash
# 唤醒 SM 智能体
/sm

# 执行 Sprint 规划
*sprint-planning
```

---

```yaml
task: sprint_planning
role: SM (Bob)
agent_activation:
  command: "/sm"
  workflow: "*sprint-planning"
invoke_workflow: "*sprint-planning"
actions:
  - name: 分析 Epic 文件
    scan:
      - "{output_folder}/*epic*.md"
    extract:
      - Epic ID 和名称
      - 所有故事标识符
      - 依赖关系

  - name: 生成 sprint-status.yaml
    output_format: |
      # Sprint Status File (SM 智能体标准格式)
      generated: {date}
      project: {project_name}
      project_key: {project_key}
      tracking_system: file-system
      story_location: "{sprint_artifacts}"

      development_status:
        epic-1: backlog
        1-1-story-name: backlog
        1-2-story-name: backlog
        epic-1-retrospective: optional
        epic-2: backlog
        2-1-story-name: backlog

  - name: 确定开发顺序
    criteria:
      - 技术依赖（基础组件优先）
      - 业务依赖（前置功能优先）
      - 优先级排序
```

---

#### Step 4.2: 故事开发循环 (5 步强制流程)

> ⚠️ **强制要求**: 对于每个故事，必须严格按照以下 5 步流程执行，禁止跳过任何步骤！

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    故事生命周期管理 (5 步强制流程)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  🔴 STEP 1: 创建用户故事 (SM - Bob) [必须]                                   │
│  ├─ 命令: /sm → *create-story                                              │
│  ├─ 输入: Epic 中的故事定义                                                  │
│  ├─ 输出: /sprint-artifacts/stories/{story-key}.md                         │
│  ├─ 状态: backlog → drafted                                                │
│  └─ 🚨 门禁: 必须确认文件已创建，否则不能继续                                  │
│                                                                             │
│  🔴 STEP 2: 校验用户故事 (SM - Bob) [必须]                                   │
│  ├─ 命令: /sm → *validate-create-story                                     │
│  ├─ 检查: 接受标准完整性、任务分解合理性、技术说明充分性                        │
│  ├─ 状态: drafted → ready-for-dev                                          │
│  └─ 🚨 门禁: 验证必须通过，失败则返回 STEP 1 修正                             │
│                                                                             │
│  🔴 STEP 3: 开发用户故事 (DEV - Amelia) [必须]                               │
│  ├─ 命令: /dev → *develop-story                                            │
│  ├─ 前置: 必须有 ready-for-dev 状态的故事文件                                 │
│  ├─ 执行: TDD 驱动开发 (红-绿-重构)                                          │
│  ├─ 状态: ready-for-dev → in-progress                                      │
│  └─ 🚨 前置检查: 如果故事文件不存在或状态不对，必须先完成 STEP 1-2              │
│                                                                             │
│  🔴 STEP 4: 自测用户故事 (DEV - Amelia) [必须]                               │
│  ├─ 命令: 运行单元测试 (npm test / pytest / go test)                        │
│  ├─ 检查: 所有测试必须 100% 通过                                             │
│  ├─ 状态: in-progress → review                                             │
│  └─ 🚨 门禁: 测试未 100% 通过则不能进入 STEP 5，必须修复                       │
│                                                                             │
│  🔴 STEP 5: 代码审查 + 集成测试 (DEV - Amelia) [必须]                         │
│  ├─ 命令: /dev → *code-review                                              │
│  ├─ 审查: 功能正确性 + 代码质量 + 安全性 + 集成兼容性                          │
│  ├─ 结果:                                                                   │
│  │   ├─ APPROVED → 状态变为 done，故事完成                                   │
│  │   └─ CHANGES_REQUESTED → 返回 STEP 3 修复                               │
│  └─ 🚨 门禁: 只有 APPROVED 才能标记 done                                     │
│                                                                             │
│  ✅ 故事完成后，返回 STEP 1 处理下一个故事                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 📊 状态流转图 (5 步流程对应)

```
                    STEP 1              STEP 2
              ┌──────────────┐    ┌──────────────┐
  backlog ────│ *create-story │───▶│ *validate    │───▶ ready-for-dev
              │  (SM)         │    │  (SM)        │
              └──────────────┘    └──────────────┘
                                         │
                                         │ STEP 3
                                         ▼
                                  ┌──────────────┐
                                  │ *develop-story│
                                  │  (DEV)        │
                                  └──────────────┘
                                         │
                                         ▼
                                    in-progress
                                         │
                                         │ STEP 4 (自测)
                                         ▼
                                  ┌──────────────┐
                                  │ 运行单元测试  │
                                  │ 100% 通过    │
                                  └──────────────┘
                                         │
                                         ▼
                                      review
                                         │
                                         │ STEP 5
                                         ▼
                                  ┌──────────────┐
                         ┌────────│ *code-review │────────┐
                         │        │  (DEV)        │        │
                         │        └──────────────┘        │
                         │                                │
                    APPROVED                      CHANGES_REQUESTED
                         │                                │
                         ▼                                │
                       done ◄─────────────────────────────┘
                                    (返回 STEP 3)
```

---

#### Step 4.2.1: 🔴 STEP 1 - 创建用户故事 (create-story) [必须]

**调用工作流**: `{xiaoma_folder}/xmc/workflows/4-implementation/create-story/workflow.yaml`

> ⚠️ **强制要求**: 此步骤为必须执行步骤，禁止跳过！必须生成故事文件后才能进入 STEP 2！

---

##### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  🔴 STEP 1: 创建用户故事 [必须]                                   │
│  智能体: Bob (SM)                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  执行步骤:                                                        │
│                                                                  │
│  1. 唤醒 SM 智能体                                               │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: /sm                                           │ │
│     │ 说明: 唤醒 Scrum Master Bob，准备创建故事文件            │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  2. 🔴 创建故事文件 [必须]                                        │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *create-story                                 │ │
│     │ 说明: 从 Epic 中提取故事定义，创建独立的故事文件          │ │
│     │ 输入: sprint-status.yaml + epics/*.md                   │ │
│     │ 输出: /sprint-artifacts/stories/{story-key}.md          │ │
│     │ 状态: backlog → drafted                                 │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 门禁检查 (GATE 1):                                            │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 必须验证故事文件已创建                                 │ │
│     │ ls -la {sprint_artifacts}/stories/{story-key}.md       │ │
│     │                                                         │ │
│     │ ❌ 如果文件不存在：禁止继续！必须先创建故事文件！         │ │
│     │ ✅ 如果文件存在：可以进入 STEP 2                         │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行命令**:
```bash
# 唤醒 SM 智能体
/sm

# 🔴 [必须] 创建故事文件
*create-story

# 🚨 门禁检查：验证故事文件已创建
ls -la {sprint_artifacts}/stories/{story-key}.md
# 如果文件不存在，禁止继续！
```

---

#### Step 4.2.2: 🔴 STEP 2 - 校验用户故事 (validate-story) [必须]

**调用工作流**: `{xiaoma_folder}/xmc/workflows/4-implementation/create-story/workflow.yaml` (validate-create-story)

> ⚠️ **强制要求**: 此步骤为必须执行步骤，禁止跳过！验证通过后才能进入 STEP 3！

---

##### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  🔴 STEP 2: 校验用户故事 [必须]                                   │
│  智能体: Bob (SM)                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  前置条件检查:                                                    │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 验证故事文件存在且状态为 drafted                       │ │
│     │ grep "Status: drafted" {sprint_artifacts}/stories/*.md  │ │
│     │                                                         │ │
│     │ ❌ 如果没有 drafted 状态的故事：返回 STEP 1              │ │
│     │ ✅ 如果存在：继续执行验证                                │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  执行步骤:                                                        │
│                                                                  │
│  1. 唤醒 SM 智能体                                               │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: /sm                                           │ │
│     │ 说明: 唤醒 Scrum Master Bob，准备验证故事                │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  2. 🔴 验证故事文件 [必须]                                        │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *validate-create-story                        │ │
│     │ 说明: 验证故事质量，检查接受标准完整性                   │ │
│     │ 验证内容:                                                │ │
│     │   - 接受标准完整性 (Given-When-Then)                    │ │
│     │   - 任务分解合理性                                       │ │
│     │   - 技术说明充分性                                       │ │
│     │ 状态: drafted → ready-for-dev                           │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 门禁检查 (GATE 2):                                            │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 验证故事状态已更新为 ready-for-dev                     │ │
│     │ grep "Status: ready-for-dev" {story-file}              │ │
│     │                                                         │ │
│     │ ❌ 验证未通过：返回 STEP 1 修正故事                       │ │
│     │ ✅ 验证通过：可以进入 STEP 3                              │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行命令**:
```bash
# 唤醒 SM 智能体
/sm

# 🔴 [必须] 验证故事文件
*validate-create-story

# 🚨 门禁检查：验证故事状态已更新
grep "Status: ready-for-dev" {sprint_artifacts}/stories/{story-key}.md
# 如果状态不是 ready-for-dev，禁止继续！
```

---

```yaml
task: prepare_story
role: SM (Bob)
agent_activation:
  command: "/sm"
  workflows:
    - trigger: "*create-story"
      purpose: "创建故事文件"
    - trigger: "*validate-create-story"
      purpose: "验证故事（推荐）"
invoke_workflow: "*create-story"

for_each: story in sprint_status.development_status
  where: status == "backlog" AND is_story (not epic/retrospective)

actions:
  - name: 创建故事文件
    inputs:
      - sprint_status: "{sprint_artifacts}/sprint-status.yaml"
      - epics_file: "{output_folder}/epics.md"
      - prd_file: "{output_folder}/PRD.md"
      - architecture_file: "{output_folder}/architecture.md"

  - name: 生成故事上下文
    include:
      - 用户故事描述
      - 接受标准 (Given-When-Then)
      - 技术说明 (Dev Notes)
      - 任务/子任务分解
      - 相关文件列表

  - name: 更新状态
    update_sprint_status:
      story_key: "backlog → drafted"

  - name: 自动验证并标记 ready-for-dev
    # SM 智能体的 create-story 支持直接标记 ready-for-dev
    validate:
      - 接受标准完整性
      - 任务分解合理性
      - 技术说明充分性
    on_pass:
      update_sprint_status:
        story_key: "drafted → ready-for-dev"
```

**故事文件格式** (符合 DEV 智能体要求):

> ⚠️ **关键**: 必须包含 `Status:` 行，且位于标题之后！

```markdown
# Story: {story-key}

Status: drafted

## Story
As a [用户角色],
I want [功能],
So that [价值].

## Acceptance Criteria
- [ ] **AC-001**: Given [条件], When [操作], Then [结果]
- [ ] **AC-002**: ...

## Tasks/Subtasks
- [ ] TASK-001: [任务描述]
  - [ ] SUBTASK-001-1: [子任务]
  - [ ] SUBTASK-001-2: [子任务]
- [ ] TASK-002: [任务描述]

## Dev Notes
### Architecture Requirements
[架构设计中的相关部分]

### Technical Specifications
[技术实现说明]

### Coding Standards
[从知识库获取的编码规范]

## Dev Agent Record
### Implementation Plan
[开发过程中填写]

### Debug Log
[调试日志]

### Completion Notes
[完成说明]

## File List
[变更的文件列表]

## Change Log
[变更日志]
```

> **注意**: `Status:` 行位于文件顶部（标题之后），不是在底部！
> 状态值将随开发进度更新: `drafted → ready-for-dev → in-progress → review → done`

---

#### Step 4.2.3: 🔴 STEP 3 - 开发用户故事 (develop-story) [必须]

**调用工作流**: `{xiaoma_folder}/xmc/workflows/4-implementation/dev-story/workflow.yaml`

> ⚠️ **强制要求**: 此步骤为必须执行步骤！必须基于 `/sprint-artifacts/stories/{story-key}.md` 故事文件进行开发！

> 🚨 **前置条件**: 必须存在状态为 `ready-for-dev` 的故事文件，否则必须返回 STEP 1-2 先创建并验证故事！

---

##### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  🔴 STEP 3: 开发用户故事 [必须]                                   │
│  智能体: Amelia (DEV)                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  前置条件检查 (强制!):                                            │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 🚨 必须验证故事文件存在且状态为 ready-for-dev          │ │
│     │ ls {sprint_artifacts}/stories/{story-key}.md           │ │
│     │ grep "Status: ready-for-dev" {story-file}              │ │
│     │                                                         │ │
│     │ ❌ 如果故事文件不存在：禁止开发！返回 STEP 1            │ │
│     │ ❌ 如果状态不是 ready-for-dev：返回 STEP 1-2            │ │
│     │ ✅ 如果存在且状态正确：继续开发                          │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  执行步骤:                                                        │
│                                                                  │
│  1. 唤醒 DEV 智能体                                              │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: /dev                                          │ │
│     │ 说明: 唤醒开发者 Amelia，准备进行 TDD 开发               │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  2. 🔴 执行故事开发工作流 [必须]                                  │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *develop-story                                │ │
│     │ 说明: 基于故事文件执行 TDD 驱动开发                      │ │
│     │ 输入: /sprint-artifacts/stories/{story-key}.md         │ │
│     │ 执行流程:                                                │ │
│     │   - Step 4: 标记为 in-progress                          │ │
│     │   - Step 5: TDD 实现 (红-绿-重构)                        │ │
│     │   - Step 6: 编写全面测试                                 │ │
│     │   - Step 7: 运行验证和测试                               │ │
│     │   - Step 8: 验证并标记任务完成                           │ │
│     │ 状态: ready-for-dev → in-progress                       │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 关键规则 (绝对不能违反):                                      │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ ❌ 禁止基于 Epic 直接开发！必须基于 Story 文件！             │ │
│  │ ❌ 禁止跳过故事文件验证！                                    │ │
│  │ ✅ 故事文件是唯一的事实来源                                  │ │
│  │ ✅ 严格按照 Tasks/Subtasks 顺序执行                          │ │
│  │ ✅ 绝不实现故事文件中未定义的内容                            │ │
│  │ ✅ 每个任务完成前必须有测试覆盖                              │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 门禁检查 (GATE 3):                                            │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 开发完成后，必须验证:                                  │ │
│     │ 1. 故事状态已变为 in-progress                           │ │
│     │ 2. 所有 Tasks 已有代码实现                               │ │
│     │ 3. 测试文件已创建                                        │ │
│     │                                                         │ │
│     │ ❌ 开发未完成：不能进入 STEP 4                            │ │
│     │ ✅ 开发完成：可以进入 STEP 4 (自测)                       │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行命令**:
```bash
# 🚨 前置检查：验证故事文件存在
ls {sprint_artifacts}/stories/{story-key}.md
grep "Status: ready-for-dev" {sprint_artifacts}/stories/{story-key}.md
# 如果检查失败，禁止继续！必须返回 STEP 1-2

# 唤醒 DEV 智能体
/dev

# 🔴 [必须] 执行故事开发 (基于故事文件！)
*develop-story
```

---

```yaml
task: develop_story
role: DEV (Amelia)
agent_activation:
  command: "/dev"
  workflow: "*develop-story"
invoke_workflow: "*develop-story"

precondition:
  - sprint_status[story_key] == "ready-for-dev"

execution_flow:
  # DEV 智能体 dev-story 工作流的 10 个步骤
  step_1: "查找 ready-for-dev 故事并加载"
  step_2: "加载项目上下文和故事信息"
  step_3: "检测是否是代码审查后的继续"
  step_4: "标记故事为 in-progress"
  step_5: "TDD 实现 (红-绿-重构)"
  step_6: "编写全面测试"
  step_7: "运行验证和测试"
  step_8: "验证并标记任务完成"
  step_9: "故事完成，标记为 review"
  step_10: "完成沟通和用户支持"

tdd_cycle:
  red_phase:
    - 根据接受标准编写失败测试
    - 确认测试失败原因是功能未实现

  green_phase:
    - 实现最小代码使测试通过
    - 运行测试确认通过

  refactor_phase:
    - 优化代码结构
    - 确保测试仍然通过

critical_rules:
  - "故事文件是唯一的事实来源"
  - "严格按照 Tasks/Subtasks 顺序执行"
  - "绝不实现故事文件中未定义的内容"
  - "每个任务完成前必须有测试覆盖"
  - "所有测试必须 100% 通过才能继续"

status_transitions:
  on_start: "ready-for-dev → in-progress"
  on_complete: "in-progress → review"

# ⚠️ 强制状态更新操作 - 必须执行！
mandatory_updates:
  on_start:
    - action: "编辑故事文件: Status: ready-for-dev → Status: in-progress"
    - action: "编辑 sprint-status.yaml: story_key: ready-for-dev → story_key: in-progress"
  on_complete:
    - action: "编辑故事文件: Status: in-progress → Status: review"
    - action: "编辑 sprint-status.yaml: story_key: in-progress → story_key: review"
```

---

#### Step 4.2.4: 🔴 STEP 4 - 代码审查 (code-review) [必须]

**调用工作流**: `{xiaoma_folder}/xmc/workflows/4-implementation/code-review/workflow.yaml`

> ⚠️ **强制要求**: 此步骤为必须执行步骤！代码审查通过 (APPROVED) 后才能进入测试验证阶段！

---

##### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  🔴 STEP 4: 代码审查 [必须]                                       │
│  智能体: Amelia (DEV)                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  前置条件检查:                                                    │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 验证故事状态为 in-progress 且单元测试已通过            │ │
│     │ grep "Status: in-progress" {story-file}                │ │
│     │ # 验证所有单元测试已通过 (STEP 3 中执行)                 │ │
│     │                                                         │ │
│     │ ❌ 如果状态不是 in-progress：返回 STEP 3                 │ │
│     │ ✅ 如果状态正确且测试通过：继续执行代码审查              │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  执行步骤:                                                        │
│                                                                  │
│  1. 唤醒 DEV 智能体 (建议全新上下文)                              │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: /dev                                          │ │
│     │ 说明: 唤醒开发者 Amelia，准备进行代码审查                │ │
│     │ 建议: 使用全新上下文和不同 LLM 以获得更客观的评估        │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  2. 🔴 执行代码审查工作流 [必须]                                  │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *code-review                                  │ │
│     │ 审查维度:                                                │ │
│     │   - 功能正确性: 是否满足所有接受标准                     │ │
│     │   - 代码质量: 清晰可读、命名规范、遵循项目规范           │ │
│     │   - 安全性: 注入风险、敏感数据处理、认证授权             │ │
│     │   - 测试覆盖: 测试充分性、边界情况覆盖                   │ │
│     │ 状态: in-progress → review                              │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 审查结果处理:                                                 │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ APPROVED (通过):                                        │ │
│     │   - 状态更新为 review                                   │ │
│     │   - 继续到 STEP 5 (测试验证)                            │ │
│     │                                                         │ │
│     │ CHANGES_REQUESTED (需修改):                             │ │
│     │   - 返回 STEP 3 修复问题                                 │ │
│     │   - 修复后重新执行 STEP 3-4                              │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 门禁检查 (GATE 4):                                            │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 代码审查结果验证                                       │ │
│     │ 1. 审查结果必须为 APPROVED                              │ │
│     │ 2. 故事状态已更新为 review                               │ │
│     │                                                         │ │
│     │ ❌ 审查未通过：返回 STEP 3 修复！                         │ │
│     │ ✅ 审查通过：可以进入 STEP 5 (测试验证)                  │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行命令**:
```bash
# 唤醒 DEV 智能体 (建议全新上下文)
/dev

# 🔴 [必须] 执行代码审查
*code-review

# 🚨 门禁检查：
# - APPROVED: 继续到 STEP 5 (测试验证)
# - CHANGES_REQUESTED: 返回 STEP 3 修复
```

---

```yaml
task: code_review
role: DEV (Amelia)
mandatory: true

precondition:
  - sprint_status[story_key] == "in-progress"
  - all_unit_tests_passed == true

review_dimensions:
  - functionality: "是否满足所有接受标准"
  - code_quality: "清晰可读、命名规范、遵循项目规范"
  - security: "注入风险、敏感数据处理、认证授权"
  - test_coverage: "测试充分性、边界情况覆盖"

gate_check:
  pass_condition: "APPROVED"
  on_pass:
    - action: "更新故事状态: in-progress → review"
    - action: "编辑故事文件: Status: in-progress → Status: review"
    - next_step: "STEP 5 - 测试验证 (TEA)"
  on_fail:
    - action: "返回 STEP 3 修复"
    - next_step: "修复后重新执行 STEP 3-4"
```

---

#### Step 4.2.5: 🔴 STEP 5 - 测试验证 (test-verification) [必须]

**调用工作流**:
- `{xiaoma_folder}/xmc/workflows/testarch/trace/workflow.yaml` (需求追溯)
- `{xiaoma_folder}/xmc/workflows/testarch/test-review/workflow.yaml` (测试质量评审)

> ⚠️ **强制要求**: 此步骤为必须执行步骤！测试验证通过后才能标记故事为 done！这是故事生命周期的最后一步！

---

##### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  🔴 STEP 5: 测试验证 [必须] - 故事生命周期最后一步               │
│  智能体: Murat (TEA)                                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  前置条件检查:                                                    │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 验证故事状态为 review 且代码审查已通过                 │ │
│     │ grep "Status: review" {story-file}                     │ │
│     │                                                         │ │
│     │ ❌ 如果状态不是 review：返回 STEP 4 完成代码审查         │ │
│     │ ✅ 如果状态正确：继续执行测试验证                        │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  执行步骤:                                                        │
│                                                                  │
│  1. 唤醒 TEA 智能体                                              │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: /tea                                          │ │
│     │ 说明: 唤醒测试架构师 Murat，准备进行测试验证             │ │
│     │ 建议: 使用全新上下文以获得更客观的测试评估               │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  2. 🔴 执行需求追溯验证 [必须]                                    │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *trace                                        │ │
│     │ 说明: 验证代码实现与需求的追溯关系                       │ │
│     │ 验证内容:                                                │ │
│     │   - 需求覆盖: 每个接受标准都有对应的代码实现             │ │
│     │   - 测试覆盖: 每个接受标准都有对应的测试用例             │ │
│     │   - 追溯完整: 需求 ↔ 代码 ↔ 测试 三向追溯                │ │
│     │   - 无遗漏: 没有未实现的需求项                           │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  3. 🔴 执行测试质量评审 [必须]                                    │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ 执行命令: *test-review                                  │ │
│     │ 说明: 评审测试用例的质量和完整性                         │ │
│     │ 评审维度:                                                │ │
│     │   - 测试充分性: 测试用例是否覆盖所有场景                 │ │
│     │   - 边界测试: 边界条件和异常情况是否测试                 │ │
│     │   - 测试质量: 断言是否明确、测试是否独立                 │ │
│     │   - 集成测试: 模块间交互是否验证                         │ │
│     │   - 回归测试: 是否可防止功能退化                         │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 验证结果处理:                                                 │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ PASS (通过):                                            │ │
│     │   - 状态: review → done                                 │ │
│     │   - 故事完成！处理下一个故事                             │ │
│     │                                                         │ │
│     │ FAIL (失败):                                            │ │
│     │   - 状态: review → in-progress                          │ │
│     │   - 返回 STEP 3 修复问题                                 │ │
│     │   - 修复后重新执行 STEP 3-5                              │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  🚨 门禁检查 (GATE 5 - 最终门禁):                                 │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 故事完成验证                                           │ │
│     │ 1. 需求追溯完整 (*trace 通过)                           │ │
│     │ 2. 测试质量达标 (*test-review 通过)                     │ │
│     │ 3. 所有测试 100% 通过                                   │ │
│     │ 4. 故事状态已更新为 done                                 │ │
│     │                                                         │ │
│     │ ❌ 验证未通过：返回 STEP 3 修复                           │ │
│     │ ✅ 验证通过：故事完成，处理下一个故事                     │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行命令**:
```bash
# 🚨 前置检查：验证故事状态为 review
grep "Status: review" {sprint_artifacts}/stories/{story-key}.md
# 如果状态不是 review，禁止继续！必须返回 STEP 4

# 唤醒 TEA 智能体 (建议全新上下文)
/tea

# 🔴 [必须] 执行需求追溯验证
*trace

# 🔴 [必须] 执行测试质量评审
*test-review

# 根据验证结果处理:
# PASS → 故事完成，处理下一个故事
# FAIL → 返回 STEP 3 修复
```

---

```yaml
task: test_verification
role: TEA (Murat)
agent_activation:
  command: "/tea"
  workflows:
    - "*trace"
    - "*test-review"
  recommendation: "使用全新上下文以获得更客观的测试评估"

precondition:
  - sprint_status[story_key] == "review"
  - code_review_result == "APPROVED"

verification_steps:
  trace:
    workflow: "*trace"
    purpose: "需求追溯验证"
    checks:
      - 每个接受标准都有对应的代码实现
      - 每个接受标准都有对应的测试用例
      - 需求 ↔ 代码 ↔ 测试 三向追溯完整
      - 没有未实现的需求项

  test_review:
    workflow: "*test-review"
    purpose: "测试质量评审"
    dimensions:
      test_adequacy:
        - 测试用例是否覆盖所有场景
        - 正常流程和异常流程是否都有测试
      boundary_testing:
        - 边界条件是否测试
        - 异常输入是否测试
      test_quality:
        - 断言是否明确
        - 测试是否独立可重复
      integration_testing:
        - 模块间交互是否验证
        - API 契约是否测试
      regression_prevention:
        - 是否可防止功能退化

verification_outcome:
  PASS:
    action: "更新状态为 done"
    update_sprint_status:
      story_key: "review → done"
    # ⚠️ 强制执行以下操作！
    mandatory_updates:
      - "编辑故事文件: Status: review → Status: done"
      - "编辑 sprint-status.yaml: story_key: review → story_key: done"

  FAIL:
    action: "生成修复任务，返回开发"
    return_to_step: "STEP 3"
    # ⚠️ 强制执行以下操作！
    mandatory_updates:
      - "编辑故事文件: Status: review → Status: in-progress"
      - "编辑 sprint-status.yaml: story_key: review → story_key: in-progress"
    note: "修复后需要重新执行 STEP 3 → STEP 4 → STEP 5"

best_practice: |
  建议使用全新上下文执行测试验证以获得更客观的评估
```

---

#### Step 4.2.6: 更新 Sprint 状态 (每个故事完成后)

```yaml
task: update_sprint_status
description: "每个故事完成 5 步流程后自动更新 Sprint 状态"
after_each_story:
  - name: 更新故事状态
    file: "{sprint_artifacts}/sprint-status.yaml"
    update:
      development_status[story_key]: "{new_status}"

  - name: 更新 Epic 状态
    logic: |
      if all_stories_in_epic == "done":
        epic_status = "done"
      elif any_story_in_epic == "in-progress" or "review":
        epic_status = "in-progress"
      else:
        epic_status = "backlog"

  - name: 计算进度
    metrics:
      total_stories: count(stories)
      completed_stories: count(stories where status == "done")
      completion_rate: completed_stories / total_stories * 100%
```

---

**TDD 执行流程详解**:

```
For Each Task in Story:
  ┌──────────────────────────────────────────────────────────────┐
  │ 1. 🔴 编写测试 (Red Phase)                                    │
  │    ├─ 查询知识库获取测试规范                                   │
  │    ├─ 根据接受标准编写测试用例                                  │
  │    ├─ 运行测试，确认失败                                       │
  │    └─ 验证失败原因是功能未实现                                  │
  ├──────────────────────────────────────────────────────────────┤
  │ 2. 🟢 实现代码 (Green Phase)                                  │
  │    ├─ 查询知识库获取编码规范                                   │
  │    ├─ 编写最小代码使测试通过                                    │
  │    ├─ 运行测试，确认通过                                       │
  │    └─ 处理边界情况和异常                                       │
  ├──────────────────────────────────────────────────────────────┤
  │ 3. 🔵 重构 (Refactor Phase)                                  │
  │    ├─ 检查代码质量（重复、复杂度）                              │
  │    ├─ 应用优化（提取方法、简化逻辑）                            │
  │    ├─ 运行测试确保仍然通过                                     │
  │    └─ 更新 Dev Agent Record                                  │
  ├──────────────────────────────────────────────────────────────┤
  │ 4. ✅ 标记任务完成                                            │
  │    ├─ 验证所有测试存在且通过                                   │
  │    ├─ 标记任务 checkbox [x]                                  │
  │    ├─ 更新 File List                                        │
  │    └─ 继续下一个任务或进入完成流程                              │
  └──────────────────────────────────────────────────────────────┘
```

**质量门禁**:
- [ ] 所有测试通过 (100%)
- [ ] 代码审查通过 (APPROVED)
- [ ] 无安全漏洞 (0 critical/high)
- [ ] 符合代码规范 (lint 通过)
- [ ] 测试覆盖率 >= 80%

---

### Step 5: Sprint 收尾与最终报告 (Phase 5) [可选]

**角色激活**: TEA (测试架构师 - Murat) / SM (Scrum Master - Bob)

> **说明**: 本阶段为可选阶段，在所有用户故事完成后执行。用于生成 Sprint 级别的综合报告和收尾工作。
> **注意**: 每个故事的测试验证已在 Phase 4 的 STEP 5 中由 TEA 完成，此阶段主要是 Sprint 级别的汇总。

---

#### 🤖 智能体执行指令

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 5: Sprint 收尾与最终报告 [可选]                            │
│  智能体: TEA (Murat) / SM (Bob)                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  前置条件检查:                                                    │
│     ┌─────────────────────────────────────────────────────────┐ │
│     │ # 验证所有故事状态为 done                                │ │
│     │ # 如果存在未完成的故事，则不执行本阶段                    │ │
│     │ grep "Status: done" {sprint_artifacts}/stories/*.md     │ │
│     └─────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Step 5.1: 唤醒 TEA 智能体 (可选 - 生成质量报告)                  │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: /tea                                              ││
│  │ 说明: 唤醒测试架构师 Murat，生成 Sprint 级别质量报告         ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 5.2: NFR 验证 (可选 - 非功能需求综合评估)                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *nfr-assess                                       ││
│  │ 说明: 验证整个 Sprint 的非功能性需求 (性能、安全、可用性)    ││
│  │ 输出: nfr-assessment-report.md                              ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 5.3: (可选) 测试自动化增强                                  │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *automate                                         ││
│  │ 说明: 生成额外的测试自动化代码                               ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 5.4: (可选) CI/CD 流水线                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 执行命令: *ci                                               ││
│  │ 说明: 搭建 CI/CD 质量流水线脚手架                           ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
│  Step 5.5: 生成 Sprint 最终报告                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 输出: sprint-summary-report.md                              ││
│  │ 内容:                                                       ││
│  │   - Sprint 执行摘要                                         ││
│  │   - 故事完成统计                                            ││
│  │   - 质量指标汇总                                            ││
│  │   - 问题和经验教训                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**执行序列** (可选):
```bash
# 前置检查：验证所有故事已完成
# 如果有未完成的故事，跳过本阶段

# 1. (可选) 唤醒 TEA 智能体进行 Sprint 级别质量报告
/tea

# 2. (可选) NFR 综合验证
*nfr-assess

# 3. (可选) 测试自动化增强
*automate

# 4. (可选) CI/CD 流水线
*ci

# 5. 生成 Sprint 最终报告
# 自动生成 sprint-summary-report.md
```

---

**自动执行内容**:

```yaml
phase: 5
name: Sprint 收尾与最终报告
optional: true
role: TEA (Murat) / SM (Bob)
precondition:
  - all_stories_status == "done"

agent_activation:
  command: "/tea"
  optional_workflows:
    - trigger: "*nfr-assess"
      purpose: "Sprint 级别非功能性需求验证"
    - trigger: "*automate"
      purpose: "测试自动化增强（可选）"
    - trigger: "*ci"
      purpose: "CI/CD 流水线（可选）"

inputs:
  - 所有已完成的故事文件
  - 各故事的测试报告
  - sprint-status.yaml
outputs:
  - sprint-summary-report.md
  - nfr-assessment-report.md (可选)

note: |
  由于每个故事已在 Phase 4 的 STEP 5 中完成 TEA 测试验证：
  - *trace (需求追溯)
  - *test-review (测试质量评审)

  本阶段主要做 Sprint 级别的汇总和可选的增强工作。
```

---

#### Step 5.1: Sprint 级别质量汇总

```yaml
task: sprint_quality_summary
optional: true
role: TEA (Murat)
description: "汇总所有故事的测试验证结果，生成 Sprint 级别报告"

aggregation:
  - name: 故事完成统计
    metrics:
      total_stories: count(stories)
      completed_stories: count(stories where status == "done")
      completion_rate: completed_stories / total_stories * 100%

  - name: 测试覆盖汇总
    metrics:
      total_tests: sum(story.test_count)
      passed_tests: sum(story.passed_tests)
      pass_rate: passed_tests / total_tests * 100%
      coverage: average(story.coverage)

  - name: 质量指标汇总
    metrics:
      code_review_issues: sum(story.review_issues)
      bugs_found: count(bugs)
      bugs_fixed: count(bugs where status == "fixed")
```

---

#### Step 5.2: NFR 综合验证 (可选)

**调用工作流**: `{xiaoma_folder}/xmc/workflows/testarch/nfr-assess/workflow.yaml`

**执行命令**: `/tea → *nfr-assess`

```yaml
task: nfr_validation
role: TEA (Murat)
optional: true
agent_command: "/tea → *nfr-assess"
invoke_workflow: "*nfr-assess"

description: "Sprint 级别的非功能性需求综合评估"

validations:
  performance:
    - nfr_id: "NFR-PERF-001"
      requirement: "页面响应时间 < 2s"
      test_method: "性能测试"

    - nfr_id: "NFR-PERF-002"
      requirement: "API 响应时间 < 500ms"
      test_method: "负载测试"

  security:
    - nfr_id: "NFR-SEC-001"
      requirement: "所有 API 需要认证"
      test_method: "安全扫描"

  usability:
    - nfr_id: "NFR-USA-001"
      requirement: "支持响应式布局"
      test_method: "多设备测试"
```

---

#### Step 5.3: 生成 Sprint 最终报告

```yaml
task: generate_sprint_report
outputs:
  - name: sprint-summary-report.md
    content:
      - Sprint 执行摘要
        - Sprint 目标
        - 计划 vs 实际完成
        - 关键成果
      - 故事完成详情
        - 已完成故事列表
        - 各故事状态
        - 工作量统计
      - 质量指标
        - 测试通过率
        - 代码覆盖率
        - 代码审查结果
      - 问题和风险
        - 遇到的阻塞问题
        - 解决方案
        - 遗留问题
      - 经验教训
        - 做得好的方面
        - 需要改进的方面
        - 下个 Sprint 建议
```

---

**Sprint 完成检查清单**:
- [ ] 所有故事状态为 done
- [ ] 所有测试验证通过 (Phase 4 STEP 5)
- [ ] sprint-status.yaml 已更新
- [ ] Sprint 最终报告已生成 (可选)
- [ ] NFR 验证通过 (可选)

---

## 阻塞处理机制

当执行过程中遇到阻塞时，按以下优先级处理：

```yaml
blocking_resolution:
  level_1_knowledge_base:
    description: 首先在知识库中检索解决方案
    actions:
      - 扩大关键词搜索范围
      - 检索相似问题的解决方案
      - 查找相关技术文档

  level_2_inference:
    description: 基于知识库推断解决方案
    actions:
      - 基于相似案例推断
      - 基于技术规范推断
      - 基于最佳实践推断

  level_3_default:
    description: 使用默认策略继续执行
    actions:
      - 采用保守的默认实现
      - 记录决策供后续审查
      - 继续执行后续步骤

  level_4_human:
    description: 标记为需人工介入（最后手段）
    actions:
      - 记录详细的阻塞信息
      - 暂停当前任务
      - 继续执行其他无依赖任务
```

---

## 状态追踪

### 1. 迭代执行状态 (`auto-iteration-status.yaml`)

执行过程中自动更新迭代级别的状态：

```yaml
# auto-iteration-status.yaml
execution:
  id: "iter-2024-001"
  started_at: "2024-01-15T10:00:00Z"
  status: "in_progress"  # pending | in_progress | completed | blocked

phases:
  phase_1_analyze:
    status: "completed"
    started_at: "2024-01-15T10:00:00Z"
    completed_at: "2024-01-15T10:15:00Z"
    outputs:
      - requirement-analysis.md

  phase_2_plan:
    status: "completed"
    outputs:
      - prd.md
      - epics/epic-001.md

  phase_3_design:
    status: "completed"
    outputs:
      - architecture.md
      - adr/

  phase_4_develop:
    status: "in_progress"
    current_story: "1-2-user-authentication"

  phase_5_test:
    status: "pending"

blocking_issues: []

knowledge_base_queries:
  - query: "用户认证最佳实践"
    result: "found"
    source: "tech-kb/auth-patterns.md"
```

### 2. Sprint 开发状态 (`sprint-status.yaml`)

**与 SM 智能体完全兼容的格式**：

```yaml
# sprint-status.yaml
# 由 SM 智能体的 sprint-planning 工作流生成
# 格式与现有项目智能体系统完全一致

# 文件元数据
generated: "2024-01-15 10:30"
project: "My Project"
project_key: "PROJ-001"
tracking_system: file-system
story_location: "{sprint_artifacts}"

# STATUS DEFINITIONS (与 SM 智能体一致):
# ==================
# Epic Status:
#   - backlog: Epic not yet started
#   - in-progress: Epic actively being worked on
#   - done: All stories in epic completed
#
# Story Status:
#   - backlog: Story only exists in epic file
#   - drafted: Story file created in stories folder
#   - ready-for-dev: Draft approved, ready for development
#   - in-progress: Developer actively working on implementation
#   - review: Implementation complete, ready for review
#   - done: Story completed

# 开发状态追踪
development_status:
  # Epic 1
  epic-1: in-progress
  1-1-user-authentication: done
  1-2-account-management: in-progress
  1-3-user-profile: ready-for-dev
  1-4-password-reset: drafted
  1-5-session-management: backlog
  epic-1-retrospective: optional

  # Epic 2
  epic-2: backlog
  2-1-product-catalog: backlog
  2-2-search-functionality: backlog
  2-3-product-details: backlog
  epic-2-retrospective: optional
```

### 3. 状态同步机制

```yaml
status_sync:
  # Phase 4 开发过程中的状态同步
  on_story_status_change:
    - update: "sprint-status.yaml"
      field: "development_status[story_key]"

    - update: "auto-iteration-status.yaml"
      field: "phases.phase_4_develop.current_story"

  # 故事状态转换触发点
  transitions:
    backlog_to_drafted:
      trigger: "*create-story 完成创建故事文件"
      update_sprint_status: true

    drafted_to_ready_for_dev:
      trigger: "*create-story 或 *validate-create-story 验证通过"
      update_sprint_status: true

    ready_for_dev_to_in_progress:
      trigger: "*develop-story Step 4 开始开发"
      update_sprint_status: true

    in_progress_to_review:
      trigger: "*develop-story Step 9 故事完成"
      update_sprint_status: true

    review_to_done:
      trigger: "*code-review APPROVED"
      update_sprint_status: true

    review_to_in_progress:
      trigger: "*code-review CHANGES_REQUESTED"
      update_sprint_status: true
      note: "DEV 智能体会处理审查反馈"
```

### 4. 强制状态更新操作 (MANDATORY)

> ⚠️ **关键**: 以下操作是**必须执行**的，不是可选的描述！

#### 4.1 Phase 4 开始前 - 创建 sprint-status.yaml

**必须首先执行** `*sprint-planning` 或手动创建：

```bash
# 在 {sprint_artifacts} 目录创建 sprint-status.yaml
# 示例路径: docs/sprint-artifacts/sprint-status.yaml
```

```yaml
# sprint-status.yaml - 必须创建此文件
generated: "{date}"
project: "{project_name}"
tracking_system: file-system
story_location: "{sprint_artifacts}"

development_status:
  epic-1: backlog
  1-1-story-name: backlog
  1-2-story-name: backlog
  # ... 列出所有故事
```

#### 4.2 状态更新文件编辑操作

**每次状态变化时，必须执行以下两个更新**：

##### 更新 1: sprint-status.yaml

```yaml
# 编辑 sprint-status.yaml 中的 development_status
# 将故事状态从旧值改为新值

# 示例: 1-1-user-auth 从 backlog 变为 drafted
development_status:
  1-1-user-auth: drafted  # 原来是 backlog
```

##### 更新 2: 故事文件

故事文件必须使用以下格式（符合 SM/DEV 智能体要求）：

```markdown
# Story 1.1: User Authentication

Status: drafted

## Story
As a user,
I want to authenticate,
so that I can access the system.

## Acceptance Criteria
...
```

**状态行位置**: 在标题之后，第一个 `## ` 节之前

**允许的状态值**:
- `drafted` - 故事文件已创建
- `ready-for-dev` - 准备开发
- `in-progress` - 开发中
- `review` - 等待审查
- `done` - 已完成

#### 4.3 状态更新检查点

在以下时间点**必须**更新状态：

| 时间点 | 触发动作 | 更新内容 |
|--------|---------|---------|
| `*create-story` 完成 | 故事文件创建 | `backlog → drafted` (或 `ready-for-dev`) |
| `*develop-story` Step 4 | 开始开发 | `ready-for-dev → in-progress` |
| `*develop-story` Step 9 | 开发完成 | `in-progress → review` |
| `*code-review` APPROVED | 审查通过 | `review → done` |

#### 4.4 验证状态更新

每个阶段完成后，验证状态一致性：

```bash
# 检查 sprint-status.yaml 中的状态
grep "story-key" sprint-status.yaml

# 检查故事文件中的状态
head -5 stories/story-key.md | grep "Status:"
```

**状态必须同步**: `sprint-status.yaml` 和故事文件中的状态必须一致！

---

## 执行完成

当所有阶段完成后，输出最终报告：

```markdown
# 迭代开发执行报告

## 执行摘要
- **执行 ID**: iter-2024-001
- **开始时间**: 2024-01-15 10:00:00
- **完成时间**: 2024-01-15 14:30:00
- **总耗时**: 4.5 小时
- **状态**: ✅ 成功完成

## 产出物清单
### 文档
- [ ] requirement-analysis.md
- [ ] prd.md
- [ ] architecture.md
- [ ] test-report.md

### 代码
- [ ] 新增文件: 12 个
- [ ] 修改文件: 8 个
- [ ] 测试文件: 15 个

### 测试结果
- 单元测试: 45/45 通过
- 集成测试: 12/12 通过
- 覆盖率: 87%

## 知识库使用统计
- 业务规则匹配: 23 条
- 技术规范引用: 15 条
- 新增知识建议: 3 条

## 后续建议
1. [建议内容]
2. [建议内容]
```
